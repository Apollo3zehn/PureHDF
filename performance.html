<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
      <title>Performance | PureHDF </title>
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <meta name="title" content="Performance | PureHDF ">
      
      <link rel="icon" href="images/icon.png">
      <link rel="stylesheet" href="public/docfx.min.css">
      <link rel="stylesheet" href="public/main.css">
      <meta name="docfx:navrel" content="toc.html">
      <meta name="docfx:tocrel" content="toc.html">
      
      
      
      
      <meta name="docfx:docurl" content="https://github.com/Apollo3zehn/PureHDF/blob/master/doc/performance.md/#L1">
  </head>

  <script type="module">
    import options from './public/main.js'
    import { init } from './public/docfx.min.js'
    init(options)
  </script>

  <script>
    const theme = localStorage.getItem('theme') || 'auto'
    document.documentElement.setAttribute('data-bs-theme', theme === 'auto' ? (window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light') : theme)
  </script>


  <body class="tex2jax_ignore" data-layout="" data-yaml-mime="">
    <header class="bg-body border-bottom">
      <nav id="autocollapse" class="navbar navbar-expand-md" role="navigation">
        <div class="container-xxl flex-nowrap">
          <a class="navbar-brand" href="index.html">
            <img id="logo" class="svg" src="images/icon.png" alt="">
            
          </a>
          <button class="btn btn-lg d-md-none border-0" type="button" data-bs-toggle="collapse" data-bs-target="#navpanel" aria-controls="navpanel" aria-expanded="false" aria-label="Toggle navigation">
            <i class="bi bi-three-dots"></i>
          </button>
          <div class="collapse navbar-collapse" id="navpanel">
            <div id="navbar">
            </div>
          </div>
        </div>
      </nav>
    </header>

    <main class="container-xxl">
      <div class="toc-offcanvas">
        <div class="offcanvas-md offcanvas-start" tabindex="-1" id="tocOffcanvas" aria-labelledby="tocOffcanvasLabel">
          <div class="offcanvas-header">
            <h5 class="offcanvas-title" id="tocOffcanvasLabel">Table of Contents</h5>
            <button type="button" class="btn-close" data-bs-dismiss="offcanvas" data-bs-target="#tocOffcanvas" aria-label="Close"></button>
          </div>
          <div class="offcanvas-body">
            <nav class="toc" id="toc"></nav>
          </div>
        </div>
      </div>

      <div class="content">
        <div class="actionbar">
          <button class="btn btn-lg border-0 d-md-none" style="margin-top: -.65em; margin-left: -.8em" type="button" data-bs-toggle="offcanvas" data-bs-target="#tocOffcanvas" aria-controls="tocOffcanvas" aria-expanded="false" aria-label="Show table of contents">
            <i class="bi bi-list"></i>
          </button>

          <nav id="breadcrumb"></nav>
        </div>

        <article data-uid="">
<h1 id="performance">Performance</h1>

<h2 id="memory-management">Memory Management</h2>
<p>PureHDF allows you to provide your own buffer so you can using for example the .NET <code>MemoryPool</code> to rent a buffer:</p>
<pre><code class="lang-cs">var dataset = (NativeDataset)file.Dataset(&quot;/the/dataset&quot;);
var length = (int)dataset.Space.Dimensions[0] * sizeof(double);

using var memoryOwner = MemoryPool&lt;byte&gt;.Shared.Rent(minBufferSize: length);
var memory = memoryOwner.Memory.Slice(0, length);

dataset.Read(buffer: memory);

var doubleData = MemoryMarshal.Cast&lt;byte, double&gt;(memory.Span);
</code></pre>
<p>Supported buffer types are <code>T</code> (in case of <code>dataset.Read&lt;T&gt;(...)</code>), <code>byte[]</code>, <code>Memory&lt;byte&gt;</code> and <code>Span&lt;byte&gt;</code>.</p>
<h2 id="chunking">Chunking</h2>
<p>The HDF5 file format is a good choice for storing compressed data in chunks, which can actually improve speed by reducing the amount of data that needs to be read from disk. However, chunked data can only be accessed as a whole (due to compression), so it is important to choose an appropriate chunk size.</p>
<p>For example, consider a two-dimensional data set with dimensions of <code>10.000 x 100</code>. This dataset will be filled with real-time sampled data where the first dimension is the time axis, i.e. there will be <code>100</code> values per sample. You could now choose a chunk size of <code>1 x 100</code>, which means that the chunk is the size of a single sample. This chunk size works well for write operations.</p>
<p>But when the measurement is finished, you want to read the data back into memory. Often the access pattern is different: instead of writing the data row by row, you now want to read the data column by column. This is often the case with measurement systems where you have tens or hundreds of individual channels. In our example, we want to read the first column - the first channel - with dimensions <code>10.000 x 1</code>.</p>
<p>To do this, PureHDF has to open all the <code>10.000</code> chunks, decompress them, extract the first values and collect them in the final array. This will severely degrade performance. If the chunk size had been set to <code>10.000 x 1</code> instead, it would have been a single read operation and much faster overall. At the same time, however, the write performance is greatly reduced, because now <code>100</code> individual chunks have to be accessed per sample, where <em>access</em> means <code>decompress -&gt; append new value -&gt; compress</code>.</p>
<p>The best solution to this problem is to use chunk caches. A chunk cache holds the decompressed data, so in case of a write operation the pattern <code>decompress -&gt; append new value -&gt; compress</code> changes to <code>find chunk in cache -&gt; append new value</code>, which is generally much faster.</p>
<p>Performance will be degraded again if the chunk cache is too small. The default <em>reading</em> chunk cache properties are</p>
<ul>
<li><code>521</code> chunk entries</li>
<li>with a maximum total size of <code>1 MB</code></li>
</ul>
<h2 id="reading">Reading</h2>
<p>The default implementation of the <code>IReadingChunkCache</code> interface is the  <code>SimpleReadingChunkCache</code>. You can change the parameters of this cache or replace it entirely with your own implementation as follows:</p>
<pre><code class="lang-cs">var dataset = (NativeDataset)file.Dataset(&quot;/the/dataset&quot;);

var datasetAccess = new H5DatasetAccess(
    ChunkCache: new SimpleReadingChunkCache(
        chunkSlotCount: 521, 
        byteCount: 1 * 1024 * 1024
    )
)

dataset.Read&lt;T&gt;(datasetAccess, ...);
</code></pre>
<h2 id="writing">Writing</h2>
<p>The default implementation of the <code>IWritingChunkCache</code> interface is the  <code>SimpleWritingChunkCache</code> which has no chunk count or chunk size limits because a current PureHDF limitation is that chunks can only be written once. Therefore the chunk cache <strong>must</strong> hold all data in memory until all other file structures are written.</p>
<p>If you want to use your own implementation of <code>IWritingChunkCache</code>, you can provide it in the <code>H5Dataset</code> constructor like this:</p>
<pre><code class="lang-cs">var datasetCreation = new H5DatasetCreation(
    ChunkCache: &lt;your own chunk cache&gt;
)

var dataset = new H5Dataset(..., datasetCreation: datasetCreation);
</code></pre>
<div class="NOTE">
<h5>Note</h5>
<p>Alternatively, you can provide the chunk caches in a central place: <code>ChunkCache.DefaultReadingChunkCacheFactory</code> for reading, or <code>ChunkCache.DefaultWritingChunkCacheFactory</code> for writing.</p>
</div>
</article>

        <div class="contribution d-print-none">
          <a href="https://github.com/Apollo3zehn/PureHDF/blob/master/doc/performance.md/#L1" class="edit-link">Edit this page</a>
        </div>

        <div class="next-article d-print-none border-top" id="nextArticle"></div>
        
      </div>

      <div class="affix">
        <nav id="affix"></nav>
      </div>
    </main>


    <footer class="border-top">
      <div class="container-xxl">
        <div class="flex-fill">
          Copyright © 2024 Vincent Wilms
        </div>
      </div>
    </footer>
  </body>
</html>